{
  "language": "Solidity",
  "sources": {
    "contracts/cpop/CPNFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/**\n * @title Gas-Optimized CPNFT Contract\n * @dev Custom implementation of NFT with batch operations and owner privileges\n * @dev Completely independent of OpenZeppelin libraries to minimize gas costs\n */\ncontract CPNFT {\n    // Token name\n    string private _name;\n    \n    // Token symbol\n    string private _symbol;\n    \n    // Base URI for token metadata\n    string private _baseTokenURI;\n    \n    // Token ID counter\n    uint256 private _tokenIdCounter;\n    \n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n    \n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n    \n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n    \n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    \n    // Contract owner\n    address private _owner;\n    \n    // Mapping to track minted tokens\n    mapping(uint256 => bool) private _mintedTokens;\n\n    // Events\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Constructor function\n     * @param name_ Name of the NFT collection\n     * @param symbol_ Symbol of the NFT collection\n     * @param baseTokenURI_ Base URI for token metadata\n     */\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        string memory baseTokenURI_\n    ) {\n        _name = name_;\n        _symbol = symbol_;\n        _baseTokenURI = baseTokenURI_;\n        _owner = msg.sender;\n        _tokenIdCounter = 1; // Start token IDs from 1\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner\n     */\n    modifier onlyOwner() {\n        require(_owner == msg.sender, \"Caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account\n     * @param newOwner The address to transfer ownership to\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        require(newOwner != address(0), \"New owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n\n    /**\n     * @dev Returns the name of the token\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for a token\n     * @param tokenId The token ID to query\n     */\n    function tokenURI(uint256 tokenId) public view returns (string memory) {\n        require(_mintedTokens[tokenId], \"Token does not exist\");\n        return string(abi.encodePacked(_baseTokenURI, _toString(tokenId)));\n    }\n\n    /**\n     * @dev Set the base URI for token metadata\n     * @param baseURI New base URI\n     */\n    function setBaseURI(string memory baseURI) external onlyOwner {\n        _baseTokenURI = baseURI;\n    }\n\n    /**\n     * @dev Returns the number of tokens in an owner's account\n     * @param owner_ The address to query the balance of\n     */\n    function balanceOf(address owner_) public view returns (uint256) {\n        require(owner_ != address(0), \"Balance query for the zero address\");\n        return _balances[owner_];\n    }\n\n    /**\n     * @dev Returns the owner of a token\n     * @param tokenId The token ID to query\n     */\n    function ownerOf(uint256 tokenId) public view returns (address) {\n        address owner_ = _owners[tokenId];\n        require(owner_ != address(0), \"Owner query for nonexistent token\");\n        return owner_;\n    }\n\n    /**\n     * @dev Check if a token exists\n     * @param tokenId ID of the token to check\n     * @return Boolean indicating if the token exists\n     */\n    function tokenExists(uint256 tokenId) public view returns (bool) {\n        return _mintedTokens[tokenId];\n    }\n\n    /**\n     * @dev Approves another address to transfer the given token ID\n     * @param to The address to approve for token transfer\n     * @param tokenId The token ID to approve\n     */\n    function approve(address to, uint256 tokenId) public {\n        address owner_ = ownerOf(tokenId);\n        require(to != owner_, \"Approval to current owner\");\n        require(msg.sender == owner_ || isApprovedForAll(owner_, msg.sender), \n                \"Approve caller is not owner nor approved for all\");\n        \n        _tokenApprovals[tokenId] = to;\n        emit Approval(owner_, to, tokenId);\n    }\n\n    /**\n     * @dev Gets the approved address for a token ID\n     * @param tokenId The token ID to query\n     */\n    function getApproved(uint256 tokenId) public view returns (address) {\n        require(_mintedTokens[tokenId], \"Approved query for nonexistent token\");\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev Sets or unsets the approval of a given operator\n     * @param operator The address to set the approval for\n     * @param approved Boolean representing the status of the approval to be set\n     */\n    function setApprovalForAll(address operator, bool approved) public {\n        require(operator != msg.sender, \"Approve to caller\");\n        \n        _operatorApprovals[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    /**\n     * @dev Checks if an operator is approved by an owner\n     * @param owner_ The owner address\n     * @param operator The operator address\n     */\n    function isApprovedForAll(address owner_, address operator) public view returns (bool) {\n        return _operatorApprovals[owner_][operator];\n    }\n\n    /**\n     * @dev Transfers a token from one address to another\n     * @param from The current owner of the token\n     * @param to The address to receive the token\n     * @param tokenId The token ID to transfer\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public {\n        require(_isApprovedOrOwner(msg.sender, tokenId), \"Transfer caller is not owner nor approved\");\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Safely transfers a token from one address to another\n     * @param from The current owner of the token\n     * @param to The address to receive the token\n     * @param tokenId The token ID to transfer\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Safely transfers a token from one address to another with additional data\n     * @param from The current owner of the token\n     * @param to The address to receive the token\n     * @param tokenId The token ID to transfer\n     * @param _data Additional data to send with the transfer\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {\n        require(_isApprovedOrOwner(msg.sender, tokenId), \"Transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Mint NFTs in batch to multiple addresses\n     * @param to Array of addresses to receive the minted NFTs\n     */\n    function batchMint(address[] calldata to) external onlyOwner() {\n        for (uint256 i = 0; i < to.length; i++) {\n            mint(to[i]);\n        }\n    }\n\n    /**\n     * @dev Mint a single NFT to an address\n     * @param to Address to receive the minted NFT\n     * @return tokenId The ID of the minted token\n     */\n    function mint(address to) public onlyOwner returns (uint256) {\n        require(to != address(0), \"Mint to the zero address\");\n        \n        uint256 tokenId = _tokenIdCounter;\n        _tokenIdCounter++;\n        \n        _balances[to] += 1;\n        _owners[tokenId] = to;\n        _mintedTokens[tokenId] = true;\n        \n        emit Transfer(address(0), to, tokenId);\n        return tokenId;\n    }\n\n    /**\n     * @dev Burn NFTs in batch\n     * @param tokenIds Array of token IDs to be burned\n     */\n    function batchBurn(uint256[] calldata tokenIds) external onlyOwner {\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            burn(tokenIds[i]);\n        }\n    }\n\n    /**\n     * @dev Burn a single NFT\n     * @param tokenId ID of the token to be burned\n     */\n    function burn(uint256 tokenId) public onlyOwner {\n        require(_mintedTokens[tokenId], \"Token does not exist\");\n        \n        address owner_ = ownerOf(tokenId);\n        \n        // Clear approvals\n        _approve(address(0), tokenId);\n        \n        _balances[owner_] -= 1;\n        delete _owners[tokenId];\n        _mintedTokens[tokenId] = false;\n        \n        emit Transfer(owner_, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfer NFTs in batch from multiple owners to multiple recipients\n     * @param from Array of current token owners\n     * @param to Array of new token owners\n     * @param tokenIds Array of token IDs to be transferred\n     */\n    function batchTransferFrom(\n        address[] calldata from,\n        address[] calldata to,\n        uint256[] calldata tokenIds\n    ) external onlyOwner {\n        require(\n            from.length == to.length && to.length == tokenIds.length,\n            \"Arrays length mismatch\"\n        );\n        \n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            transferFrom(from[i], to[i], tokenIds[i]);\n        }\n    }\n\n    /**\n     * @dev Get the current token ID counter value\n     * @return Current token ID count\n     */\n    function getCurrentTokenId() external view returns (uint256) {\n        return _tokenIdCounter - 1;\n    }\n\n    /**\n     * @dev Get the next token ID that will be minted\n     * @return Next token ID\n     */\n    function getNextTokenId() external view returns (uint256) {\n        return _tokenIdCounter;\n    }\n\n    /**\n     * @dev Internal function to transfer a token\n     * @param from The current owner of the token\n     * @param to The address to receive the token\n     * @param tokenId The token ID to transfer\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        require(ownerOf(tokenId) == from, \"Transfer from incorrect owner\");\n        require(to != address(0), \"Transfer to the zero address\");\n        \n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n        \n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n        \n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to safely transfer a token\n     * @param from The current owner of the token\n     * @param to The address to receive the token\n     * @param tokenId The token ID to transfer\n     * @param _data Additional data to send with the transfer\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal {\n        _transfer(from, to, tokenId);\n        // Simplified version - in a production environment, you might want to check if the recipient is a contract\n        // and can handle ERC721 tokens, but we're omitting that to save gas\n    }\n\n    /**\n     * @dev Internal function to approve an address for a token\n     * @param to The address to approve\n     * @param tokenId The token ID to approve\n     */\n    function _approve(address to, uint256 tokenId) internal {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to check if an address is approved or owner of a token\n     * @param spender The address to check\n     * @param tokenId The token ID to check\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\n        require(_mintedTokens[tokenId], \"Operator query for nonexistent token\");\n        \n        // Special operators can always transfer\n        if (spender == _owner) {\n            return true;\n        }\n        \n        address owner_ = ownerOf(tokenId);\n        return (spender == owner_ || getApproved(tokenId) == spender || isApprovedForAll(owner_, spender));\n    }\n\n    /**\n     * @dev Converts a uint256 to its ASCII string representation\n     * @param value The uint256 value to convert\n     */\n    function _toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly (\"memory-safe\") {\n                ptr := add(add(buffer, 0x20), length)\n            }\n            while (true) {\n                ptr--;\n                assembly (\"memory-safe\") {\n                    mstore8(ptr, byte(mod(value, 10), \"0123456789abcdef\"))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n}"
    }
  },
  "settings": {
    "evmVersion": "cancun",
    "viaIR": true,
    "optimizer": {
      "enabled": true,
      "runs": 1000000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}